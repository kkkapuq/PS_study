'''
1. 한번에 3개 이하의 계단까지.
2. 연속된 3개의 계단을 오를 수는 없음
3. 마지막 계단은 무조건 밟아야됨
4. 시작점은 카운팅에 포함되지않음 (1부터 시작하면될듯)
'''

'''
시뮬레이션 굴려보기
시작 - 10 20 15 25 10 20 
아이디어 1. 현재 자리를 기준으로 연속된 3개에서 2개의 조합으로 가장 많이 점수를 담으면 된다.
반례) 10 40 30 100 10 20
-> 정답은 10, 40, 100, 20 = 170
-> 하지만 이 아이디어로 하면 40, 30으로 왔다고 치자. 
-> 근데 2번 조건에 의해 100을 못챙긴다.

아이디어 2. 현재 지점에서 3개중에 가장 높은 친구만 찾아간다
반례)30 20 40 100 10 20
-> 40, 100, 20 = 160
-> 30, 20, 100, 20 = 170
-> 여기서 나올 수 있는건 170이라 안됨

그니까 당장 눈앞의 큰것을 바라보면 안됨...
아이디어 3. 하나 올라갔을 때랑 두개 올라갔을 때 비교해서 큰놈 넣기...?
반례) 30 50 40 100 10 20
정답 = 30 50 100 20 = 200
-> 50, 100, 20 = 170 이 나와버림...
-> 2칸 올라간 상태에서 생각해보면 맞는데?
-> 근데 만약에 30 50 100 40 10 20 이면
-> 50 100 40 20 = 210 이 된단말이지
-> 이 아이디어대로 하면 30 50 100을 못챙김
-> 그럼 1 2 랑 2 3 이랑 비교했을 때 스타트를 끊고 그 다음 인덱스까지 고려해야되지않음?
-> 1 2랑 2 3이랑 비교를 해봅시다...
-> 마지막 전계단을 밟는거랑 안밟는것도 체크해야될거같은데.

'''

n = int(input())

# 점수를 저장할 리스트와 계단별 점수가 들어가는 리스트
scores = []
stairs = []

# 계단 점수입력
for i in range(n):
    stairs.append(int(input()))
    
if n == 1:
    print(stairs[0])
    exit()
elif n == 2:
    print(stairs[0] + stairs[1])
    exit()

scores.append(stairs[0])
scores.append(stairs[0] + stairs[1])
scores.append(max(stairs[1]+stairs[2], stairs[0]+stairs[2]))

# 마지막 전 계단을 밟지 않은 경우와 밟은 경우
for i in range(3, n):
    # 마지막 전 계단을 밟은 경우는 3번째 전계단의 점수 + 전계단 + 마지막계단 이 최대값이고
    # 마지막 전 계단을 안 밟은 경우는 2번째 전계단 + 마지막 계단이 최대값이다.
    scores.append(max(scores[i-3] + stairs[i-1] + stairs[i], scores[i-2] + stairs[i]))
    
print(scores[n-1])