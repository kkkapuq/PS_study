'''
크기가 NxN 은 2차원 배열이므로, n이 3이라면 다음과 같다
A(0,0) [0]
A(0,1) [0]
A(0,2) [0]
A(1,0) [0]
A(1,1) [1]
A(1,2) [2]
A(2,0) [0]
A(2,1) [2]
A(2,2) [4]

즉, 이런 모양으로 있음
[0][0][0]
[0][1][2]
[0][2][4]

4까지 늘려본다면...

A(0,0) [0]
A(0,1) [0]
A(0,2) [0]
A(0,3) [0]
A(1,0) [0]
A(1,1) [1]
A(1,2) [2]
A(1,3) [3]
A(2,0) [0]
A(2,1) [2]
A(2,2) [4]
A(2,3) [6]
A(3,0) [0]
A(3,1) [3]
A(3,2) [6]
A(3,3) [9]

풀어쓰면
[0][0][0][0]
[0][1][2][3]
[0][2][4][6]
[0][3][6][9]

이 수들을 B에 넣고, 오름차순 정렬한뒤 K번째 수를 찾는것

각 수들은 n번째 행에서 구구단처럼 다음 원소가 생성된다.
k번째 수보다 작거나 같은 애들만 찾아서 cnt 해주면 이 cnt가 몇번째 수인지 알 수 있다.
그냥 for문 돌려서 n*m을 다 구할 필요 없음.

'''

n = int(input())
k = int(input())

# k번째 수를 구해야 하니 start를 1로 두자
start, end = 1, k
answer = 0
while start <= end:
    # 이분탐색의 mid 정하기
    mid = (start + end) // 2
    # 임의의 수
    temp = 0
    for i in range(1, n+1):
        # 임의의 수는 mid 이하의 i의 배수 or 최대 N
        temp += min(mid//i, n)

    if temp >= k:
        answer = mid
        end = mid - 1
    else:
        start = mid + 1
print(answer)